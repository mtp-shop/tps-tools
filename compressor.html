<!-- START OF FILE compressor.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TPS STUDIOS | DATA CRUSHER</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- GIF Encoder Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Inter:wght@300;400;600&display=swap');

        :root {
            --bg: #020202;
            --panel: #080808;
            --border: #1a1a1a;
            --accent: #ff9d00;
            --text-main: #e0e0e0;
            --text-muted: #555;
        }

        * { box-sizing: border-box; outline: none; margin: 0; padding: 0; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; z-index: -1; pointer-events: none;
        }

        .exit-btn {
            position: absolute; top: 30px; right: 30px; z-index: 500;
            background: black; padding: 10px 20px; border: 1px solid #333;
            color: #666; font-family: 'Rajdhani'; font-weight: 700; cursor: pointer;
            border-radius: 4px; transition: 0.2s; font-size: 0.8rem; text-decoration: none;
        }
        .exit-btn:hover { color: var(--accent); border-color: var(--accent); }

        .toolbar {
            position: absolute; top: 30px; left: 30px; width: 360px;
            background: rgba(8, 8, 8, 0.95); backdrop-filter: blur(20px);
            border: 1px solid var(--border); padding: 30px;
            border-radius: 4px; z-index: 500;
            display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            max-height: 90vh; overflow-y: auto;
        }
        
        .tool-header {
            font-family: 'Rajdhani'; font-weight: 700; letter-spacing: 1px; font-size: 1.2rem;
            border-bottom: 1px solid #222; padding-bottom: 15px; margin-bottom: 5px;
            display: flex; justify-content: space-between; align-items: center; color: white;
        }
        .status-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 10px var(--accent); }

        .control-label {
            font-size: 0.7rem; color: #666; text-transform: uppercase; font-weight: 700; letter-spacing: 1px; margin-bottom: 8px; margin-top: 10px;
        }

        input[type="file"] { display: none; }
        .file-upload {
            border: 1px dashed #333; padding: 25px; text-align: center; border-radius: 4px;
            cursor: pointer; transition: 0.2s; color: #555; font-size: 0.8rem; font-weight: 600;
            display: flex; flex-direction: column; gap: 10px; align-items: center;
            background: #0c0c0c;
        }
        .file-upload i { font-size: 1.5rem; }
        .file-upload:hover { border-color: var(--accent); color: var(--accent); }
        .file-info { font-size: 0.7rem; color: #444; }

        input[type="number"] {
            background: #111; border: 1px solid #333; color: var(--accent); padding: 10px;
            width: 100%; font-family: 'Rajdhani'; font-weight: 700; font-size: 1rem;
        }

        select {
            width: 100%; background: #0c0c0c; border: 1px solid #333; color: white;
            padding: 15px; font-family: 'Inter'; border-radius: 4px; outline: none; margin-top: 5px;
        }
        select:focus { border-color: var(--accent); }

        .btn-action {
            background: var(--text-main); color: black; border: none; padding: 15px;
            font-family: 'Rajdhani'; font-weight: 800; text-transform: uppercase; letter-spacing: 2px;
            cursor: pointer; transition: 0.2s; width: 100%; margin-top: 20px;
        }
        .btn-action:hover { background: var(--accent); }
        .btn-action:disabled { background: #222; color: #444; cursor: not-allowed; }

        .results-panel {
            background: #111; border: 1px solid #222; padding: 15px; margin-top: 20px; display: none;
        }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .stat-val { color: white; font-family: 'Rajdhani'; font-weight: 700; }
        .stat-val.highlight { color: var(--accent); }

        .center-stage {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-image: repeating-linear-gradient(45deg, #050505 0, #050505 10px, #080808 10px, #080808 20px);
            z-index: 1; padding: 80px 80px 80px 400px; flex-direction: column;
        }
        
        .preview-container {
            max-width: 80%; max-height: 60vh; border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.5); position: relative;
            background: black; display: flex; justify-content: center; align-items: center;
        }
        video, audio, img { max-width: 100%; max-height: 100%; display: block; }
        
        .progress-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 4px; background: #222;
        }
        .progress-fill { height: 100%; width: 0%; background: var(--accent); transition: width 0.1s; }
        
        .processing-badge {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 1px solid var(--accent); color: var(--accent);
            padding: 10px 30px; font-family: 'Rajdhani'; font-weight: 700; letter-spacing: 2px;
            display: none; z-index: 10;
        }

        .checkbox-row { display: flex; gap: 10px; align-items: center; margin-top: 10px; }
        .checkbox-row input { width: auto; height: auto; }
        .checkbox-row label { font-size: 0.7rem; color: #888; }

    </style>
</head>
<body>

    <div class="scanlines"></div>
    <a href="index.html" class="exit-btn">RETURN TO SYSTEM</a>

    <!-- LEFT PANEL -->
    <div class="toolbar">
        <div class="tool-header">DATA CRUSHER <div class="status-dot"></div></div>
        
        <!-- STEP 1: UPLOAD -->
        <div>
            <div class="control-label">01 // Source Media</div>
            <input type="file" id="inp-file" accept="video/mp4, video/webm, audio/mp3, audio/wav, image/gif">
            <label class="file-upload" for="inp-file" id="lbl-file">
                <i class="fa-solid fa-file-arrow-up"></i>
                <span>Drop MP4, MP3, or GIF</span>
            </label>
            <div class="file-info" id="file-meta">No file loaded</div>
        </div>

        <!-- STEP 2: SETTINGS -->
        <div id="settings-group" style="opacity: 0.5; pointer-events: none; transition: 0.3s;">
            <div class="control-label">02 // Target Size (MB)</div>
            <div style="display:flex; gap:10px; align-items:center;">
                <input type="number" id="inp-target" value="10" min="0.1" step="0.1">
                <span style="font-family:'Rajdhani'; font-weight:700; color:#444;">MB</span>
            </div>
            <div class="file-info" id="est-bitrate" style="margin-top:5px;">Est. Bitrate: 0 kbps</div>

            <div id="video-options">
                <div class="control-label">Resolution</div>
                <select id="sel-res">
                    <option value="1">Original Resolution</option>
                    <option value="0.75">720p (HD)</option>
                    <option value="0.5">480p (SD)</option>
                    <option value="0.25">Mobile (Low)</option>
                </select>
            </div>

            <!-- GIF Specific Options -->
            <div id="gif-options" style="display:none; border-top:1px solid #222; margin-top:10px; padding-top:10px;">
                <div class="control-label">GIF Settings</div>
                <div class="checkbox-row">
                    <input type="checkbox" id="chk-gif-out">
                    <label for="chk-gif-out">Export as .GIF (Slower/Larger)</label>
                </div>
                <div class="file-info" style="margin-top:5px;">Default: Converts GIF to WebM (Smaller)</div>
            </div>
        </div>

        <button class="btn-action" id="btn-start" onclick="startCompression()" disabled>INITIALIZE CRUSH</button>

        <!-- RESULTS -->
        <div class="results-panel" id="results">
            <div class="stat-row"><span>Original</span> <span class="stat-val" id="res-orig">0 MB</span></div>
            <div class="stat-row"><span>Result</span> <span class="stat-val highlight" id="res-new">0 MB</span></div>
            <div class="stat-row"><span>Reduction</span> <span class="stat-val" id="res-percent">0%</span></div>
            <button class="btn-action" style="margin-top:10px; padding:10px; font-size:0.8rem;" onclick="downloadFile()">SAVE FILE</button>
        </div>
    </div>

    <!-- MAIN VIEW -->
    <div class="center-stage">
        <div class="preview-container" id="media-container">
            <!-- Media Elements will be injected here via JS to ensure clean state -->
            <div class="processing-badge" id="badge-process">PROCESSING... <span id="pct-process">0%</span></div>
            
            <video id="vid-preview" playsinline muted style="display:none"></video>
            <audio id="aud-preview" controls style="display:none; width: 300px;"></audio>
            <img id="img-preview" style="display:none;">

            <!-- Hidden Canvas -->
            <canvas id="hidden-canvas" style="display:none;"></canvas>
            
            <div class="progress-overlay"><div class="progress-fill" id="prog-fill"></div></div>
        </div>
        <div style="margin-top: 15px; font-family: 'Rajdhani'; color: #444; text-transform: uppercase; letter-spacing: 2px; font-size: 0.8rem;">
            Local Processing Cluster
        </div>
    </div>

    <script>
        // --- WORKER BLOB FOR GIF.JS ---
        const gifWorkerBlob = new Blob([`
            importScripts('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
        `], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(gifWorkerBlob);
        
        // DOM ELEMENTS
        const inpFile = document.getElementById('inp-file');
        const lblFile = document.getElementById('lbl-file');
        const fileMeta = document.getElementById('file-meta');
        let vidPreview = document.getElementById('vid-preview');
        let audPreview = document.getElementById('aud-preview');
        let imgPreview = document.getElementById('img-preview');
        const mediaContainer = document.getElementById('media-container');
        const hiddenCanvas = document.getElementById('hidden-canvas');
        const ctx = hiddenCanvas.getContext('2d');
        const btnStart = document.getElementById('btn-start');
        const settingsGroup = document.getElementById('settings-group');
        const inpTarget = document.getElementById('inp-target');
        const estBitrateLbl = document.getElementById('est-bitrate');
        const progFill = document.getElementById('prog-fill');
        const badge = document.getElementById('badge-process');
        const resultsPanel = document.getElementById('results');

        // STATE
        let sourceFile = null;
        let mediaType = null;
        let processedBlob = null;
        let originalSize = 0;
        let mediaDuration = 0;
        let animationId = null; // To cancel loops

        // 1. FILE HANDLING
        inpFile.addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(!f) return;
            loadMedia(f);
        });
        
        lblFile.addEventListener('dragover', (e) => { e.preventDefault(); lblFile.style.borderColor = 'var(--accent)'; });
        lblFile.addEventListener('dragleave', (e) => { e.preventDefault(); lblFile.style.borderColor = '#333'; });
        lblFile.addEventListener('drop', (e) => {
            e.preventDefault(); lblFile.style.borderColor = '#333';
            if(e.dataTransfer.files[0]) loadMedia(e.dataTransfer.files[0]);
        });

        // HELPER: Recreate DOM elements to fix "Source already connected" audio bug
        function resetMediaElements() {
            // Remove old elements
            if(vidPreview) vidPreview.remove();
            if(audPreview) audPreview.remove();
            if(imgPreview) imgPreview.remove();

            // Create fresh Video
            vidPreview = document.createElement('video');
            vidPreview.id = 'vid-preview';
            vidPreview.playsInline = true;
            vidPreview.muted = true;
            vidPreview.style.display = 'none';
            vidPreview.style.maxWidth = '100%';
            vidPreview.style.maxHeight = '100%';
            mediaContainer.insertBefore(vidPreview, hiddenCanvas);

            // Create fresh Audio
            audPreview = document.createElement('audio');
            audPreview.id = 'aud-preview';
            audPreview.controls = true;
            audPreview.style.display = 'none';
            audPreview.style.width = '300px';
            mediaContainer.insertBefore(audPreview, hiddenCanvas);

            // Create fresh Img
            imgPreview = document.createElement('img');
            imgPreview.id = 'img-preview';
            imgPreview.style.display = 'none';
            imgPreview.style.maxWidth = '100%';
            imgPreview.style.maxHeight = '100%';
            mediaContainer.insertBefore(imgPreview, hiddenCanvas);
        }

        function loadMedia(f) {
            // STOP any running animation loop
            if(animationId) cancelAnimationFrame(animationId);

            // FRESH DOM
            resetMediaElements();

            // RESET STATE
            btnStart.innerText = "INITIALIZE CRUSH";
            btnStart.disabled = false;
            resultsPanel.style.display = 'none';
            badge.style.display = 'none';
            progFill.style.width = '0%';
            processedBlob = null;
            document.getElementById('video-options').style.display = 'none';
            document.getElementById('gif-options').style.display = 'none';

            sourceFile = f;
            originalSize = f.size;
            const mb = (f.size / (1024*1024)).toFixed(2);
            fileMeta.innerText = `${f.name} (${mb} MB)`;
            fileMeta.style.color = "var(--accent)";

            const url = URL.createObjectURL(f);

            // Handle Types
            if(f.type.startsWith('video')) {
                mediaType = 'video';
                vidPreview.style.display = 'block';
                vidPreview.src = url;
                document.getElementById('video-options').style.display = 'block';
                vidPreview.onloadedmetadata = () => {
                    mediaDuration = vidPreview.duration;
                    calcBitrate();
                };
            } else if (f.type.startsWith('audio')) {
                mediaType = 'audio';
                audPreview.style.display = 'block';
                audPreview.src = url;
                audPreview.onloadedmetadata = () => {
                    mediaDuration = audPreview.duration;
                    calcBitrate();
                };
            } else if (f.type.includes('gif')) {
                mediaType = 'gif';
                imgPreview.src = url; 
                imgPreview.style.display = 'block';
                document.getElementById('video-options').style.display = 'block';
                document.getElementById('gif-options').style.display = 'block';
                mediaDuration = 5; 
                calcBitrate();
            } else {
                alert("Unsupported Format."); return;
            }

            settingsGroup.style.opacity = '1';
            settingsGroup.style.pointerEvents = 'all';
        }

        // 2. AGGRESSIVE BITRATE CALCULATION (1.5x Multiplier)
        inpTarget.addEventListener('input', calcBitrate);

        function calcBitrate() {
            if(!mediaDuration || mediaDuration === 0) return 2500000;
            
            const targetBits = parseFloat(inpTarget.value) * 8388608; 
            const audioOverhead = mediaDuration * 128000;
            let videoAvailableBits = targetBits - audioOverhead;
            if(videoAvailableBits < 0) videoAvailableBits = targetBits * 0.5;

            let rawBps = videoAvailableBits / mediaDuration;

            // 1.5x Multiplier to fix browser undershoot
            let bps = Math.floor(rawBps * 1.5);

            if(bps > 500000000) bps = 500000000; 
            if(bps < 50000) bps = 50000; 
            
            estBitrateLbl.innerText = `Target Bitrate: ${(bps/1000).toFixed(0)} kbps`;
            return bps;
        }

        // 3. MAIN ENGINE
        async function startCompression() {
            btnStart.disabled = true;
            badge.style.display = 'block';
            progFill.style.width = '0%';

            const targetBps = calcBitrate();
            const scale = parseFloat(document.getElementById('sel-res').value);

            if (mediaType === 'video') {
                processVideo(targetBps, scale);
            } else if (mediaType === 'audio') {
                processAudio(targetBps);
            } else if (mediaType === 'gif') {
                processGif(targetBps, scale);
            }
        }

        // --- VIDEO ENGINE ---
        function processVideo(bps, scale) {
            // 1. Setup Audio Context only when needed to prevent locks
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const dest = audioCtx.createMediaStreamDestination();
            
            // 2. Create source from FRESH video element
            const source = audioCtx.createMediaElementSource(vidPreview);
            source.connect(dest);
            // Connect to speakers so user can hear (optional, but good)
            // source.connect(audioCtx.destination); 
            
            vidPreview.muted = false; // Unmute so stream has audio
            vidPreview.volume = 1.0;
            vidPreview.currentTime = 0;
            vidPreview.loop = false;

            const w = vidPreview.videoWidth * scale;
            const h = vidPreview.videoHeight * scale;
            hiddenCanvas.width = w; hiddenCanvas.height = h;

            const canvasStream = hiddenCanvas.captureStream(30);
            if(dest.stream.getAudioTracks().length > 0) {
                canvasStream.addTrack(dest.stream.getAudioTracks()[0]);
            }

            const recorder = new MediaRecorder(canvasStream, {
                mimeType: 'video/webm; codecs=vp9',
                videoBitsPerSecond: bps 
            });

            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, {type:'video/webm'});
                finishProcess(blob);
                
                // Cleanup Audio
                source.disconnect();
                audioCtx.close();
                vidPreview.muted = true;
                if(animationId) cancelAnimationFrame(animationId);
            };

            recorder.start();
            vidPreview.play();

            function draw() {
                if(vidPreview.paused || vidPreview.ended) return;
                ctx.drawImage(vidPreview, 0, 0, w, h);
                const pct = ((vidPreview.currentTime / vidPreview.duration)*100).toFixed(1);
                progFill.style.width = pct + '%';
                document.getElementById('pct-process').innerText = pct + '%';
                animationId = requestAnimationFrame(draw);
            }
            draw();

            vidPreview.onended = () => recorder.stop();
        }

        // --- AUDIO ENGINE ---
        function processAudio(bps) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const dest = audioCtx.createMediaStreamDestination();
            const source = audioCtx.createMediaElementSource(audPreview);
            source.connect(dest);
            
            audPreview.loop = false;

            const recorder = new MediaRecorder(dest.stream, {
                mimeType: 'audio/webm',
                audioBitsPerSecond: bps
            });

            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                finishProcess(new Blob(chunks, {type:'audio/webm'}));
                source.disconnect();
                audioCtx.close();
            };

            audPreview.currentTime = 0;
            recorder.start();
            audPreview.play();

            const interval = setInterval(() => {
                const pct = ((audPreview.currentTime / audPreview.duration)*100).toFixed(1);
                progFill.style.width = pct + '%';
                document.getElementById('pct-process').innerText = pct + '%';
                if(audPreview.ended) { clearInterval(interval); recorder.stop(); }
            }, 100);
        }

        // --- GIF ENGINE ---
        async function processGif(bps, scale) {
            if (!('ImageDecoder' in window)) {
                alert("Browser not supported for GIF crush. Use Chrome/Edge.");
                btnStart.disabled = false;
                badge.style.display = 'none';
                return;
            }

            const isGifOut = document.getElementById('chk-gif-out').checked;
            const stream = sourceFile.stream();
            const decoder = new ImageDecoder({data: stream, type: 'image/gif'});
            
            await decoder.decode({frameIndex: 0});
            const track = decoder.tracks.selectedTrack;
            
            const w = imgPreview.naturalWidth * scale;
            const h = imgPreview.naturalHeight * scale;
            hiddenCanvas.width = w; hiddenCanvas.height = h;
            
            let gifEncoder = null;
            let videoRecorder = null;
            let videoChunks = [];

            if (isGifOut) {
                gifEncoder = new GIF({
                    workers: 2,
                    quality: 20, 
                    width: w,
                    height: h,
                    workerScript: workerUrl
                });
                gifEncoder.on('finished', (blob) => finishProcess(blob, 'gif'));
            } else {
                const canvasStream = hiddenCanvas.captureStream(30);
                videoRecorder = new MediaRecorder(canvasStream, {
                    mimeType: 'video/webm; codecs=vp9',
                    videoBitsPerSecond: bps
                });
                videoRecorder.ondataavailable = e => videoChunks.push(e.data);
                videoRecorder.onstop = () => finishProcess(new Blob(videoChunks, {type:'video/webm'}));
                videoRecorder.start();
            }

            const frameCount = track.frameCount;
            
            for (let i = 0; i < frameCount; ++i) {
                const result = await decoder.decode({frameIndex: i});
                
                ctx.clearRect(0,0,w,h);
                ctx.drawImage(result.image, 0, 0, w, h);
                
                if (isGifOut) {
                    const delay = result.image.duration ? (result.image.duration / 1000) : 100;
                    gifEncoder.addFrame(ctx, {copy: true, delay: delay});
                } else {
                    const duration = result.image.duration ? (result.image.duration / 1000) : 100;
                    await new Promise(r => setTimeout(r, duration)); 
                }

                const pct = ((i / frameCount) * 100).toFixed(0);
                progFill.style.width = pct + '%';
                document.getElementById('pct-process').innerText = pct + '%';
            }

            if (isGifOut) {
                document.getElementById('pct-process').innerText = "RENDERING...";
                gifEncoder.render();
            } else {
                videoRecorder.stop();
            }
        }

        function finishProcess(blob, extOverride) {
            processedBlob = blob;
            if(extOverride) processedBlob.ext = extOverride;
            
            badge.style.display = 'none';
            btnStart.disabled = false;
            btnStart.innerText = "CRUSH COMPLETE";
            resultsPanel.style.display = 'block';

            const oldMB = (originalSize / (1024*1024)).toFixed(2);
            const newMB = (blob.size / (1024*1024)).toFixed(2);
            const ratio = (100 - ((blob.size / originalSize) * 100)).toFixed(1);
            
            document.getElementById('res-orig').innerText = oldMB + " MB";
            document.getElementById('res-new').innerText = newMB + " MB";
            document.getElementById('res-percent').innerText = ratio + "%";
        }

        function downloadFile() {
            if(!processedBlob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(processedBlob);
            
            let ext = 'webm';
            if(mediaType === 'audio') ext = 'webm'; 
            if(mediaType === 'gif') ext = 'webm'; 
            if(processedBlob.ext === 'gif') ext = 'gif'; 

            a.download = `crushed_file.${ext}`;
            a.click();
        }

    </script>
</body>
</html>