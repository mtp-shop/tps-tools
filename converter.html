<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TPS STUDIOS | FORMAT SHIFTER v2.0</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Inter:wght@300;400;600&display=swap');

        :root {
            --bg: #020202;
            --panel: #080808;
            --border: #1a1a1a;
            --accent: #00e5ff;
            --text-main: #e0e0e0;
            --text-muted: #555;
        }

        * { box-sizing: border-box; outline: none; margin: 0; padding: 0; }
        
        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* FX */
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; z-index: -1; pointer-events: none;
        }

        /* APP LAYOUT */
        .exit-btn {
            position: absolute; top: 30px; right: 30px; z-index: 500;
            background: black; padding: 10px 20px; border: 1px solid #333;
            color: #666; font-family: 'Rajdhani'; font-weight: 700; cursor: pointer;
            border-radius: 4px; transition: 0.2s; font-size: 0.8rem; text-decoration: none;
        }
        .exit-btn:hover { color: var(--accent); border-color: var(--accent); }

        .toolbar {
            position: absolute; top: 30px; left: 30px; width: 340px;
            background: rgba(8, 8, 8, 0.95); backdrop-filter: blur(20px);
            border: 1px solid var(--border); padding: 30px;
            border-radius: 4px; z-index: 500;
            display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            max-height: 90vh; overflow-y: auto;
        }
        
        .tool-header {
            font-family: 'Rajdhani'; font-weight: 700; letter-spacing: 1px; font-size: 1.2rem;
            border-bottom: 1px solid #222; padding-bottom: 15px; margin-bottom: 5px;
            display: flex; justify-content: space-between; align-items: center; color: white;
        }
        .status-dot { width: 6px; height: 6px; background: var(--accent); border-radius: 50%; box-shadow: 0 0 10px var(--accent); }

        .control-label {
            font-size: 0.7rem; color: #666; text-transform: uppercase; font-weight: 700; letter-spacing: 1px; margin-bottom: 8px; margin-top: 10px;
        }

        /* Inputs */
        input[type="file"] { display: none; }
        .file-upload {
            border: 1px dashed #333; padding: 15px; text-align: center; border-radius: 4px;
            cursor: pointer; transition: 0.2s; color: #555; font-size: 0.8rem; font-weight: 600;
            display: block; width: 100%; background: #0c0c0c;
        }
        .file-upload:hover { border-color: var(--accent); color: var(--accent); }

        select {
            width: 100%; background: #0c0c0c; border: 1px solid #333; color: white;
            padding: 15px; font-family: 'Inter'; border-radius: 4px; outline: none;
        }
        select:focus { border-color: var(--accent); }

        input[type="range"] {
            width: 100%; height: 2px; background: #333; border-radius: 2px; appearance: none; cursor: pointer; display: block;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 0;
            cursor: pointer; border: 2px solid black;
        }

        .toggle-row { display: flex; gap: 10px; }
        .toggle-btn {
            flex: 1; background: #0c0c0c; border: 1px solid #333; color: #555; padding: 10px;
            font-size: 0.7rem; text-transform: uppercase; cursor: pointer; font-family: 'Rajdhani'; font-weight: 700;
        }
        .toggle-btn.active { background: var(--accent); color: black; border-color: var(--accent); }

        /* Action Button */
        .btn-action {
            background: var(--text-main); color: black; border: none; padding: 15px;
            font-family: 'Rajdhani'; font-weight: 800; text-transform: uppercase; letter-spacing: 2px;
            cursor: pointer; transition: 0.2s; width: 100%; margin-top: 20px;
        }
        .btn-action:hover { background: var(--accent); }
        .btn-action:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Canvas Area */
        .canvas-wrapper {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-image: radial-gradient(#111 1px, transparent 1px);
            background-size: 40px 40px; z-index: 1; padding: 80px 80px 80px 400px;
        }
        canvas { 
            max-width: 100%; max-height: 100%; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); 
            border: 1px solid #222;
            background-image: linear-gradient(45deg, #111 25%, transparent 25%), linear-gradient(-45deg, #111 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #111 75%), linear-gradient(-45deg, transparent 75%, #111 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Dynamic Options */
        .opt-group { display: none; }
        .opt-group.active { display: block; }
        .info-text { font-size: 0.75rem; color: #444; margin-top: 10px; line-height: 1.4; border-left: 2px solid #333; padding-left: 10px; }

    </style>
</head>
<body>

    <div class="scanlines"></div>

    <!-- MAIN APP -->
    <!-- FIXED: LINKED BACK TO INDEX.HTML -->
    <a href="index.html" class="exit-btn">RETURN TO SYSTEM</a>

    <div class="toolbar">
        <div class="tool-header">FORMAT SHIFTER <div class="status-dot"></div></div>
        
        <!-- STEP 1 -->
        <div>
            <div class="control-label">01 // Source File</div>
            <input type="file" id="inp-file" accept="image/png, image/jpeg, image/webp">
            <label class="file-upload" for="inp-file" id="lbl-file">Select File</label>
        </div>

        <!-- STEP 2 -->
        <div>
            <div class="control-label">02 // Target Format</div>
            <select id="sel-format" onchange="updateUI()">
                <option value="jpeg">JPG / JPEG (Standard)</option>
                <option value="webp">WEBP (High Efficiency)</option>
                <option value="svg">SVG (Web Vector)</option>
                <option value="ico">ICO (Windows Icon)</option>
                <option value="obj">OBJ (3D Heightmap Mesh)</option>
            </select>
        </div>

        <!-- STEP 3: DYNAMIC SETTINGS -->
        
        <!-- Quality Slider (JPG/WEBP) -->
        <div id="opt-quality" class="opt-group active">
            <div class="control-label" style="display:flex; justify-content:space-between;">
                <span>Compression Quality</span> <span id="val-qual">90%</span>
            </div>
            <input type="range" id="rng-qual" min="0.1" max="1.0" step="0.1" value="0.9">
        </div>

        <!-- Background Color (JPG Only) -->
        <div id="opt-bg" class="opt-group active">
            <div class="control-label">Matte Color</div>
            <div class="toggle-row">
                <button class="toggle-btn active" id="bg-black" onclick="setBg('black')">BLACK</button>
                <button class="toggle-btn" id="bg-white" onclick="setBg('white')">WHITE</button>
            </div>
        </div>

        <!-- Size Select (ICO Only) -->
        <div id="opt-size" class="opt-group">
            <div class="control-label">Icon Size</div>
            <select id="sel-size">
                <option value="32">32 x 32 (Standard)</option>
                <option value="64">64 x 64 (HD)</option>
                <option value="128">128 x 128 (Large)</option>
                <option value="256">256 x 256 (Max)</option>
            </select>
            <div class="info-text">
                Generates a valid binary .ico file with a PNG-compressed container.
            </div>
        </div>

        <!-- 3D Settings (OBJ Only) -->
        <div id="opt-3d" class="opt-group">
            <div class="control-label">Height Strength</div>
            <input type="range" id="rng-z-height" min="1" max="100" step="1" value="30">
            
            <div class="control-label" style="margin-top:15px">Mesh Density (Step)</div>
            <select id="sel-mesh-res">
                <option value="1">Ultra (1:1 Pixel Match) - Slow</option>
                <option value="2">High (1/2 Resolution)</option>
                <option value="4" selected>Medium (1/4 Resolution)</option>
                <option value="10">Low (Fast)</option>
            </select>
            <div class="info-text">
                Brighter pixels become peaks. Darker pixels become valleys.
            </div>
        </div>

        <!-- SVG Info (SVG Only) -->
        <div id="opt-svg" class="opt-group">
             <div class="info-text">
                Creates an SVG container with your image embedded. Preserves transparency.
             </div>
        </div>

        <button id="btn-process" class="btn-action" onclick="processFile()">CONVERT FILE</button>
    </div>

    <div class="canvas-wrapper">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let srcImg = new Image();
        let isLoaded = false;
        let bgColor = 'black'; 
        
        // 1. Handle File Upload
        document.getElementById('inp-file').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(!f) return;
            
            document.getElementById('lbl-file').innerText = f.name.substring(0,25);
            
            const reader = new FileReader();
            reader.onload = (ev) => {
                srcImg.onload = () => {
                    isLoaded = true;
                    render();
                };
                srcImg.src = ev.target.result;
            }
            reader.readAsDataURL(f);
        });

        // 2. UI Updates
        const rngQual = document.getElementById('rng-qual');
        rngQual.addEventListener('input', () => {
            document.getElementById('val-qual').innerText = Math.round(rngQual.value * 100) + '%';
            render();
        });

        document.getElementById('sel-size').addEventListener('change', render);

        function setBg(color) {
            bgColor = color;
            document.getElementById('bg-black').className = color === 'black' ? 'toggle-btn active' : 'toggle-btn';
            document.getElementById('bg-white').className = color === 'white' ? 'toggle-btn active' : 'toggle-btn';
            render();
        }

        function updateUI() {
            const fmt = document.getElementById('sel-format').value;
            
            // Hide all first
            document.querySelectorAll('.opt-group').forEach(el => el.classList.remove('active'));

            if (fmt === 'jpeg') {
                document.getElementById('opt-quality').classList.add('active');
                document.getElementById('opt-bg').classList.add('active');
            } else if (fmt === 'webp') {
                document.getElementById('opt-quality').classList.add('active');
            } else if (fmt === 'ico') {
                document.getElementById('opt-size').classList.add('active');
            } else if (fmt === 'svg') {
                document.getElementById('opt-svg').classList.add('active');
            } else if (fmt === 'obj') {
                document.getElementById('opt-3d').classList.add('active');
            }
            render();
        }

        // 3. Render Canvas
        function render() {
            if (!isLoaded) return;

            const fmt = document.getElementById('sel-format').value;
            let w = srcImg.width;
            let h = srcImg.height;

            // Handle Resizing for ICO (Force Square)
            if (fmt === 'ico') {
                const s = parseInt(document.getElementById('sel-size').value);
                w = s; h = s; 
            }

            canvas.width = w;
            canvas.height = h;

            // Background Fill Logic
            // OBJ and SVG usually prefer raw data, but OBJ needs data to read
            if (fmt === 'jpeg' || (fmt === 'ico' && bgColor !== 'transparent')) {
                // JPG needs solid BG. ICO works better transparent, but if user forces it...
                if(fmt === 'jpeg') {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, w, h);
                } else {
                    ctx.clearRect(0,0,w,h);
                }
            } else {
                ctx.clearRect(0, 0, w, h);
            }

            // Draw Image
            ctx.drawImage(srcImg, 0, 0, w, h);
        }

        // 4. Processing Logic
        async function processFile() {
            if(!isLoaded) return alert("Please select a file first.");
            
            const btn = document.getElementById('btn-process');
            btn.innerText = "PROCESSING...";
            btn.disabled = true;

            // Allow UI to update before heavy lifting
            setTimeout(async () => {
                const fmt = document.getElementById('sel-format').value;
                const qual = parseFloat(document.getElementById('rng-qual').value);
                
                try {
                    if(fmt === 'ico') await downloadICO();
                    else if(fmt === 'obj') downloadOBJ();
                    else if(fmt === 'svg') downloadSVG();
                    else downloadRaster(fmt, qual);
                } catch (e) {
                    alert("Error: " + e);
                }

                btn.innerText = "CONVERT FILE";
                btn.disabled = false;
            }, 100);
        }

        // --- EXPORT: RASTER (JPG/WEBP) ---
        function downloadRaster(fmt, qual) {
            let mimeType = 'image/png';
            let ext = 'png';
            if(fmt === 'jpeg') { mimeType = 'image/jpeg'; ext = 'jpg'; }
            if(fmt === 'webp') { mimeType = 'image/webp'; ext = 'webp'; }

            const dataUrl = canvas.toDataURL(mimeType, qual);
            triggerDownload(dataUrl, `converted.${ext}`);
        }

        // --- EXPORT: SVG ---
        function downloadSVG() {
            const imgData = canvas.toDataURL('image/png');
            const w = canvas.width;
            const h = canvas.height;
            const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
                <image href="${imgData}" width="${w}" height="${h}" />
            </svg>`;
            
            const blob = new Blob([svgString], {type: 'image/svg+xml'});
            triggerDownload(URL.createObjectURL(blob), "converted.svg");
        }

        // --- EXPORT: TRUE BINARY ICO ---
        function downloadICO() {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        const pngData = new Uint8Array(reader.result);
                        
                        // 1. ICO Header (6 bytes)
                        // Reserved (2), Type (2) [1=ico], Count (2) [1 image]
                        const header = new Uint8Array([0, 0, 1, 0, 1, 0]);

                        // 2. Directory Entry (16 bytes)
                        const w = canvas.width > 255 ? 0 : canvas.width; // 0 means 256
                        const h = canvas.height > 255 ? 0 : canvas.height;
                        const size = pngData.length;
                        const offset = 22; // 6 (header) + 16 (entry)

                        const entry = new Uint8Array(16);
                        const view = new DataView(entry.buffer);
                        
                        view.setUint8(0, w);          // Width
                        view.setUint8(1, h);          // Height
                        view.setUint8(2, 0);          // Palette count
                        view.setUint8(3, 0);          // Reserved
                        view.setUint16(4, 1, true);   // Color planes
                        view.setUint16(6, 32, true);  // Bits per pixel
                        view.setUint32(8, size, true); // Size of image data
                        view.setUint32(12, offset, true); // Offset of image data

                        // 3. Concatenate
                        const icoFile = new Uint8Array(header.length + entry.length + pngData.length);
                        icoFile.set(header, 0);
                        icoFile.set(entry, header.length);
                        icoFile.set(pngData, header.length + entry.length);

                        const finalBlob = new Blob([icoFile], {type: 'image/vnd.microsoft.icon'});
                        triggerDownload(URL.createObjectURL(finalBlob), "converted.ico");
                        resolve();
                    }
                    reader.readAsArrayBuffer(blob);
                }, 'image/png');
            });
        }

        // --- EXPORT: 3D OBJ (HEIGHTMAP) ---
        function downloadOBJ() {
            const w = canvas.width;
            const h = canvas.height;
            const imgData = ctx.getImageData(0, 0, w, h).data;
            
            const step = parseInt(document.getElementById('sel-mesh-res').value);
            const zStrength = parseInt(document.getElementById('rng-z-height').value);
            const scale = zStrength / 255;

            let output = `# TPS Format Shifter OBJ Export\n# Vertices: Approx ${Math.floor((w*h)/(step*step))}\n`;
            output += `o Mesh\n`;

            // Generate Vertices
            // We iterate y then x
            let vertCount = 0;
            
            // Pre-calculate vertices grid to handle skipping
            // rows[y][x] = vertexIndex
            let grid = {}; 

            for (let y = 0; y < h; y += step) {
                for (let x = 0; x < w; x += step) {
                    const i = (y * w + x) * 4;
                    // Grayscale brightness = (r+g+b)/3
                    const brightness = (imgData[i] + imgData[i+1] + imgData[i+2]) / 3;
                    const z = brightness * scale;
                    
                    // Invert Y for 3D space usually, but keeping it simple
                    // Format: v x y z
                    output += `v ${x} ${z} ${y}\n`;
                    vertCount++;
                    
                    if(!grid[y]) grid[y] = {};
                    grid[y][x] = vertCount;
                }
            }

            output += "\n# Faces\n";

            // Generate Faces
            for (let y = 0; y < h - step; y += step) {
                for (let x = 0; x < w - step; x += step) {
                    // Get indices of the quad
                    // p1--p2
                    // |    |
                    // p3--p4
                    
                    const p1 = grid[y][x];
                    const p2 = grid[y][x+step];
                    const p3 = grid[y+step][x+step];
                    const p4 = grid[y+step][x];

                    if (p1 && p2 && p3 && p4) {
                        output += `f ${p1} ${p4} ${p2}\n`;
                        output += `f ${p4} ${p3} ${p2}\n`;
                    }
                }
            }

            const blob = new Blob([output], {type: 'text/plain'});
            triggerDownload(URL.createObjectURL(blob), "heightmap_mesh.obj");
        }

        function triggerDownload(url, name) {
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    </script>
</body>
</html>